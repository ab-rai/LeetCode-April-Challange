/*
Difficulty Level=4/10 (requires hashing concepts )
Given an integer array arr, count how many elements x there are, such that x + 1 is also in arr.
If there're duplicates in arr, count them seperately.

Example 1:
Input: arr = [1,2,3]
Output: 2
Explanation: 1 and 2 are counted cause 2 and 3 are in arr.

Example 2:
Input: arr = [1,1,3,3,5,5,7,7]
Output: 0
Explanation: No numbers are counted, cause there's no 2, 4, 6, or 8 in arr.

Example 3:
Input: arr = [1,3,2,3,5,0]
Output: 3
Explanation: 0, 1 and 2 are counted cause 1, 2 and 3 are in arr.

Example 4:
Input: arr = [1,1,2,2]
Output: 2
Explanation: Two 1s are counted cause 2 is in arr.

Example 5:
Input: arr = [1,1,2]
Output: 2
Explanation: Both 1s are counted because 2 is in the array.

Constraints:
   1 <= arr.length <= 1000
   0 <= arr[i] <= 1000
*/

class Solution {
public:
    int countElements(vector<int>& arr) {
        int cnt=0,len=arr.size();
        if(arr.empty())
            return cnt;
        map<int,int> mp;
        for(int i:arr)
            mp[i]++;  // storing how many times each number is appering
        for(pair<int,int> p:mp)
        {
            if(mp.find(p.first+1)!=mp.end()) // if num+1 exist in the HashMap this emplies that we have to increment
            {                                // the counter by the value of HashMap of current key(frequency of current number)
                cnt+=p.second;
            }
        }
        return cnt;
    }
};
//Time Complexity:-O(n)
//Space Complexity:-O(n)
 
